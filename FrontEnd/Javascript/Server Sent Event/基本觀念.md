# 基本觀念

1. js 透過 new EventSource(url) 來建立連線
1. 然後 server 就可以透過 response.write() 來傳送資料給 client
1. response header 通常會設定
   1.  content-type 為 text/event-stream
   1.  用來存放連線的 HttpContext 物件
1. response.write() 的內容格式，每個 property 內容以 \n，data: 以 \n 結尾
   1.  id: 用來傳送事件的 id
   1.  data: 用來傳送資料
   1.  event: 用來傳送事件名稱
   1.  retry: 用來設定重新連線的時間間隔


### 範例

client 端
- 有多個按鈕，對 server 進行連線
- 可以向後端送出 message，對所有的 connected client 進行廣播


```cs
using System.Collections.Concurrent;
using Microsoft.AspNetCore.Mvc;

namespace MvcSSE01.Controllers;

public class ServerSentEventController : Controller
{
    private readonly ILogger<ServerSentEventController> _logger;

    public ServerSentEventController(ILogger<ServerSentEventController> logger)
    {
        _logger = logger;
    }

    [HttpGet]
    public IActionResult Index()
    {
        return View();
    }

    [HttpGet, Route("api/[Controller]/[Action]/{id}")]
    public async Task Connect(CancellationToken cancellationToken,
                              string            id)
    {
        _logger.LogInformation($"Connect: {id}");

        HttpContext.Response.Headers.Add("Content-Type",  "text/event-stream");
        HttpContext.Response.Headers.Add("Cache-Control", "no-cache");

        var addResult = _clients.TryAdd(id, HttpContext);
        _logger.LogInformation($"AddResult: {addResult}");
        
        // set id
        await HttpContext.Response.WriteAsync($"id: {id}\n\n");
        
        // set retry interval
        await HttpContext.Response.WriteAsync("retry: 10000\n\n");

        while (!(
                    cancellationToken.IsCancellationRequested
                 || HttpContext.RequestAborted.IsCancellationRequested
                ))
        {
            // await HttpContext.Response.WriteAsync($"data: {DateTime.Now:O}\n\n");
            // await HttpContext.Response.Body.FlushAsync();

            await Task.Delay(1000);
        }

        _logger.LogInformation($"Disconnect: {id}");
        var removeResult = _clients.TryRemove(id, out _);
        _logger.LogInformation($"RemoveResult: {removeResult}");
    }

    /// <summary>
    /// 用來存放連線的 HttpContext 物件
    /// 基本上要有一個 Id，方便後續移除
    /// </summary>
    private static readonly ConcurrentDictionary<string, HttpContext> _clients = new();

    [HttpGet]
    public IActionResult Index01()
    {
        return View();
    }

    [HttpPost, Route("api/[Controller]/[Action]")]
    public async Task SendMessage([FromBody]string message)
    {
        _logger.LogInformation($"SendMessage:{message}");

        HttpContext.Response.Headers.Add("Content-Type",  "text/event-stream");
        HttpContext.Response.Headers.Add("Cache-Control", "no-cache");
        
        foreach (var client in _clients)
        {
            await client.Value.Response.WriteAsync($"data:{message}\n\n");
            await client.Value.Response.Body.FlushAsync();
        }
    }
}
```

```html
@{
    ViewData["Title"] = "Home Page";
}

<h3>Server Sent Event Index</h3>

<div class="mb-3" >
    <button class="btn btn-primary"
            id="btnSection1"
            type="button" >
    </button>
    <button class="btn btn-primary"
            id="btnSection2"
            type="button" >
    </button>
    <button class="btn btn-primary"
            id="btnSection3"
            type="button" >
    </button>
    <button class="btn btn-primary"
            id="btnSection4"
            type="button" >
    </button>
</div>
<div class="mb-3" >
    <label class="form-label"
           for="message" >
        Message
    </label>
    <input class="form-control"
           id="message"
           type="text" />
</div>
<div class="mb-3" >
    <button class="btn btn-primary"
            id="btnSend"
            type="button" >
        Send
    </button>
</div>

<script>

window.ServerSentEvent = function(id) {
    // id => btn id
    const self = this;
    self.id = id;
    
    self.clickBtn = function () {
        if (self.isListening) {
            self.eventSource.close();
            self.isListening = false;
            self.updateButton('Start');
        } else {
            self.connect();
        }
    }
    
    self.updateButton = function (text) {
        document.getElementById(self.id).innerText = self.id + ' ' + text;
    }
    
    self.connect = function () {
        if (self.isListening) {
           return; 
        }
        
        self.isListening = true;
        self.updateButton('Stop');
        self.eventSource = new EventSource(self.serverSentEventUrl);
        
        self.eventSource.onopen = function (event) {
            console.log('SSE Open', event);
        };
        
        self.eventSource.onmessage = function (event) {
            console.log(self.id, event.data);
        };
        
        self.eventSource.onerror = function (event) {
            console.log('SSE Error', event);
        };
    }
    
    document.getElementById(id).addEventListener('click', self.clickBtn);
    self.isListening = false;
    self.updateButton('Start');
    self.serverSentEventUrl = '/api/ServerSentEvent/Connect/' + id;
}

const sse1 = new ServerSentEvent('btnSection1');
const sse2 = new ServerSentEvent('btnSection2');
const sse3 = new ServerSentEvent('btnSection3');
const sse4 = new ServerSentEvent('btnSection4');

document.getElementById('btnSend').addEventListener('click', function () {
    const message = document.getElementById('message').value;
    fetch('/api/ServerSentEvent/SendMessage', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(message)
    }).then(function (response) {
        console.log('response status', response.status);
    })
});

</script>
```