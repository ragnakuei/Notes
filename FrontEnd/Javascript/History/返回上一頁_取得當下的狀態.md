# 返回上一頁_取得當下的狀態


List.html

```html
<html>

<body>
    <style></style>

    <style>
        [v-cloak] {
            display: none;
        }
    </style>

    <p>List</p>
    <div id="app"
         v-cloak>
        <div>

            <table>
                <thead>
                    <tr>
                        <th>編號</th>
                        <th>名稱</th>
                        <th></th>
                    </tr>
                </thead>
                <tbody>
                    <tr v-for="item in pagedItems">
                        <td>{{ item.id }}</td>
                        <td>{{ item.name }}</td>
                        <td>
                            <button type="button"
                                    v-on:click="edit">edit</button>
                        </td>
                    </tr>
                </tbody>
            </table>

            <div>
                <button type="button"
                        v-on:click="pageDto.page--">上一頁</button>
                <span>{{ pageDto.page }}</span>
                <button type="button"
                        v-on:click="pageDto.page++">下一頁</button>
            </div>

        </div>
    </div>

    <script src="https://unpkg.com/vue@next"></script>
    <script>
        const { createApp, ref, reactive, onMounted, computed } = Vue;

        const app = createApp({
            setup() {

                onMounted(() => {
                });

                // 依照上述規則，用 array 再產生 100 筆資料
                const items = ref(Array.from({ length: 100 }, (v, i) => ({
                    id: i,
                    name: `item${i}`
                })));

                const pageDto = ref({
                    page: 1,
                    pageSize: 10,
                    total: items.value.length,
                });

                // 進入頁面時，如果有，就將 history.state 的 pageDto 資料載入
                if (history.state) {
                    pageDto.value = history.state;
                }

                const pagedItems = computed(() => {
                    const start = (pageDto.value.page - 1) * pageDto.value.pageSize;
                    const end = start + pageDto.value.pageSize;
                    return items.value.slice(start, end);
                });

                function edit() {
                    window.location.href = 'edit.html';
                }

                // 離開頁面前，先儲存資料
                window.addEventListener('unload', function (e) {

                    // 將 pageDto 存入 history.state
                    // 1. 一定要用 replaceState，不然會多一筆
                    // 2. 一定要用 ...pageDto.value，不然會變成 Proxy 而導致無法存入
                    history.replaceState({ ...pageDto.value }, null, null);
                });

                return {
                    items,
                    pageDto,
                    pagedItems,
                    edit,
                };
            },
        });

        const vm = app.mount("#app");
    </script>

</body>

</html>
```


Edit.html

```html
<html>

<body>
    <style></style>

    <p>Edit</p>
    <div>
        <button type="button"
                onclick="toList()">To List</button>
        <button type="button"
                onclick="back()">back</button>
    </div>

    <script>
        function toList() {
            window.location.href = 'list.html';

            // 會 pushState 一筆，但 state 為 null
            // 所以 List.html 就無法取得前一次所儲存的 pageDto
        }

        function back() {
            history.back();

            // 透過 history 回到前一頁，就可以取得前一次所儲存的 state
        }
    </script>

</body>

</html>
```