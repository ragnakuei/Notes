# 範例02

套用 Pinia subscribe 至 dialog 運作上

讓 vue component 內的所有變數，都從 store 取得


```js
const { defineStore } = Pinia;

const useStore = defineStore("dialog", {
    state: () => ({
        // 是否顯示
        isOpen: false,
        // icon 類型:primary, secondary, success, danger, warning, info, light, dark 
        iconType: 'primary',
        // message:顯示的訊息
        message: '',
        // delay:多少 ms 後自動隱藏
        delay: 0,
    }),
    actions: {},
});

export default useStore;
```


```js
// 用來通知使用者網站內容已更新，並且提供重新整理頁面的按鈕
const { defineComponent, onMounted, ref, computed, nextTick } = Vue;

const [
    { default: icon }, 
    { default: useDialogStore }, 
] = await Promise.all([
    import( '/js/vue/components/shared/icon.js'.appendVer() ),
    import( '/js/vue/store/dialog.js'.appendVer() ),
])
export default defineComponent({
    components: {
        icon,
    },
    template: `
<div ref="notifyInformationToastDom" class="toast hide" v-bind:class="toastClass" role="alert" aria-live="assertive" aria-atomic="true">
    <div class="d-flex align-items-center justify-content-around flex-nowrap">
        <div class="toast-body d-flex justify-content-center align-items-center gap-3 fs-5">
            <icon type="check"></icon> 
            {{ useStore.message }}
        </div>
        <div>
            <button type="button" class="btn-close me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
        </div>
    </div>
</div>
    `,
    setup() {

        const notifyInformationToastDom = ref(null);
        const notifyInformationToastInstance = ref(null);
        const useStore = useDialogStore();
        const toastClass = computed(() => {
            return 'text-' + useStore.iconType ?? 'primary';
        });


        async function show() {

            // 為了先同步 toastClass 的值，否則會無法顯示 toast
            await nextTick();
            notifyInformationToastInstance.value.show();

            if ( useStore.delay > 0 ) {
                setTimeout(() => {
                    useStore.$patch({ isOpen: false });
                }, useStore.delay);
            }
        }

        // 不顯示
        function hide() {
            notifyInformationToastInstance.value.hide();
        }

        // 監聽 store.isOpen 的變化
        // useStore.$subscribe((store) => {
        //     if ( store.payload.isOpen ) {
        //         show();
        //     } else {
        //         hide();
        //     }
        // })

        // 用 watch 也可以，直接指定 store 的 property，會更為明確
        watch(() => useStore.isOpen, (isOpen) => {
            if ( isOpen ) {
                show();
            } else {
                hide();
            }
        })

        onMounted(() => {
            notifyInformationToastInstance.value = new bootstrap.Toast(notifyInformationToastDom.value, {
                autohide: false,
                animation: true,
            })
        })

        return {
            notifyInformationToastDom,
            useStore,
            toastClass,
            show,
            hide,
        };
    }
});
```