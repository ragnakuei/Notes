# 暴力執行

## Thread

```csharp
void Main()
{
    var threads = Enumerable.Range(1, 100).Select(i => {
        var t = new Thread(TestRun);
        t.IsBackground = true;
        t.Start();
        return t;
    }).ToArray();
    
    
    
    foreach (var t in threads)
    {
        while (t.IsAlive)
        {
            Thread.Sleep(1);
        }

        $"Thread ID:{t.ManagedThreadId} IsAlive:{t.IsAlive}".Dump();
    }
}

private void TestRun()
{
    Thread.Sleep(1000);
}
```


## Task

如果把 TestRunAsync 改成同步語法，就沒有實際多執行緒的效果

```csharp
void Main()
{
    var tasks = Enumerable.Range(1, 100).Select(i =>
    {
        return Task.Run(TestRunAsync);
    });

    Task.WaitAll(tasks.ToArray());

    foreach (var t in tasks)
    {
        $"Thread ID:{t.Id} Status:{t.Status}".Dump();
    }
}

private async Task TestRunAsync()
{
    await Task.Delay(1000);
}
```
