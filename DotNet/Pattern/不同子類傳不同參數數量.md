# 不同子類傳不同參數數量

因為 繼承/實作 在 method signature 上要保持一致

可以透過下面的語法來達到 `不同子類傳不同參數數量`

```csharp
void Main()
{
	BaseClass c = new TestA();
	c.SetOption(new TestAOption { Id = 1});
	
	c = new TestB();
	c.SetOption(new TestBOption { Age = 18, Name = "A"});
}
// 不同子類需要不同 option， 不同子類的 option 沒有相同之處
public abstract class BaseClass
{
	public abstract void SetOption(object option);
}
// ---------------------------------------------------------------------
public abstract class BaseClass<TOption> : BaseClass
{
	public override void SetOption(object option)
	{
		if(option is TOption tOption)
		{
			SetOption(tOption);
            return;
		}

        // 未對應，產生 Exception
        throw new Exception();
	}

	public abstract void SetOption(TOption option);
}
// ---------------------------------------------------------------------
public class TestA : BaseClass<TestAOption>
{
	public override void SetOption(TestAOption option)
	{
		option.Id.Dump();
	}
}

public class TestB : BaseClass<TestBOption>
{
	public override void SetOption(TestBOption option)
	{
		option.Age.Dump();
		option.Name.Dump();
	}
}
// ---------------------------------------------------------------------
public class TestAOption 
{
	public int Id { get; set; }	
}

public class TestBOption 
{
	public int Age { get; set; }
	public string Name { get; set; } = string.Empty;
}
```