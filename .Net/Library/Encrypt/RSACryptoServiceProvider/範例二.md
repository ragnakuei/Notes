# 範例二

> 待確認：pem public key 是否能與 pem private key 搭配 ← 目前無效

以 pem private Key 來產生 xml private key 及 xml public key

```csharp
void Main()
{
	var rsaPrivateKey = @"MIIEpAIBAAKCAQEAws06YOs/jOBSmeLt7Uml+xB5XkR+xFWzVmL7ZtSbM6Y6hoyH
Mn9MJbkhteEpyjdGBaKYSW6SNbynENtaavMer32jjJE0Hc5dDUx1avizeI8PKdao
ufCBuUwyC+8BPkiE98ykzWj8LXwKU3tygb9kwg/C52V/2ZdWdMoUh89WPDMbYrle
JyTk1aX7L2sPzoCRgYGN/Z/5+ci73xrVuR/UGxcq/ELq0kI9fC+dP0/OzE8vgQf8
YkMsLWAaTuIiFjNt9q4Va2vBVjyOshhCJW861kf44j24b4tWnonbrcQWMBaZBB/7
anoL7tW0QYQkgnGKHny36ee7/dNoeoDzGi+O1QIDAQABAoIBAQCQm1y82aWBZHys
88J/pW5rY51VFy+re5r3g97wRN85hipn+yXZnJngXv/hTlaBYGrAgCTgTg6HiZXT
c6I5RmT/DRs9nAS+I5T77Eg1so0376rn+guijCEgdqmoJjIcFCVw9h9YxJh/A1d/
BWLJYlTfomei8rvnwOpTJDf9YTK42ENxCinyqPWoPfuixrpEjRie133svlEhGZpi
E4AfJ1skiqoAqRjasOdmyq8mcOp8WNx+wXAt4j8Gdk2q1iMfp8C9C8Fwjo0oo7PS
dadiqnpmYhP4i6bics4YsxBp28fGYdQI78h3vVnK8OsDDqlLc4BUU0N2dDBHPwzd
LVaarUDBAoGBAOu56CLzV48muCjv0fRCedlQvfxO3wq/nHXlDWXprdQe07QMbhq5
gpk7Po4fGol0R2WAFH64fQ1n8KC+7OJJcuhHVjgrndJhxqAxd6TFZaBTalNKrd8s
FtoHiU2TBf6faNSETxaa1keAIGbkUPQp5iKJxsjvOsLsenu3lZQKOXNpAoGBANOO
RFbYT5R2zjp5w136rjc6VG4UBAmCVUyZICswfcOuu63a/NlsFIIFLK3AHJjuOVp4
hDFrVPWxFdRWcc2CNHGUYLO1cYW3uKROa1+2Y47zfiYZY8wuc1DNLKU7UFO7Go20
3oPi25cCOLT+2kdqCsIvKk+KL1I7Ofu3DA99OU6NAoGAch/KbIllnc/AH0mkW16H
wZees3W39Gs6I7XmW63b07OtCSFveQ7RVMBjE8mpPl0GZ/Svd354RLJKxHhLFW87
64sGCiHLwdxGnq30X9iV0B4yfurL7R1aXuqBJgaFQ3YH+cOoyqfiEDHO/iGRs/RJ
D/WmQQfZah+1WQpTp52fnOkCgYBjKXlQ9719ip6p/C8eGwWUL4wpuMoXpvbSm6ff
drBMi9e+6zm/tBB8zW4e10DQUkGh7YGRJI1DSMlBqW9Yc+KfJnyZX8AhfHdY1MUx
rO1HsUx9EUOdDlzREAsQPBgv1zDgIVp3mVtykgEAncC03rjCQpdjhxMdSVOpcCiA
DiNRdQKBgQDUdGey/tSOF7LrD7clHMRoXNQuloZbPhQsIXpCD/JsFrmrCa2myIu4
aCWHLAjblPqLgget1sWmN5+4egwkc/k1GnjnoXGMx5Ts4M7yCYMASyT/32LSLhOD
S/TaBPPqXrLWXRGvT5jvmcBe42gpGuRBHQqTLIB7czlW6KFDokVUJQ==";

	var rsaService = new RsaService(rsaPrivateKey);


	var text = "123一二三";
	Console.WriteLine("RSA // Text to encrypt: " + text);

	var enc = rsaService.Encrypt(text);
	Console.WriteLine("RSA // Encrypted Text: " + enc);

	var dec = rsaService.Decrypt(enc);
	Console.WriteLine("RSA // Decrypted Text: " + dec);
}

public class RsaService
{
	public RsaService()
	{
		_rsaServiceProvider = new RSACryptoServiceProvider(2048);

		_privateKey = _rsaServiceProvider.ToXmlString(true);
		_publicKey = _rsaServiceProvider.ToXmlString(false);

	}

	public RsaService(string privatePkcs8PKey)
	{
		_rsaServiceProvider = CreateRsaProviderFromPrivateKey(privatePkcs8PKey);

		_privateKey = _rsaServiceProvider.ToXmlString(true);
		_publicKey = _rsaServiceProvider.ToXmlString(false);
	}

	public string PublicKey => _publicKey;

	public string Encrypt(string data)
	{
		_rsaServiceProvider.FromXmlString(_publicKey);

		var dataToEncrypt = _encoder.GetBytes(data);

		var encryptedByteArray = _rsaServiceProvider.Encrypt(dataToEncrypt, false);

		return Convert.ToBase64String(encryptedByteArray);
	}

	public string Decrypt(string data)
	{
		_rsaServiceProvider.FromXmlString(_privateKey);

		var dataArray = Convert.FromBase64String(data);

		var decryptedByte = _rsaServiceProvider.Decrypt(dataArray, false);

		return _encoder.GetString(decryptedByte);
	}

	private RSACryptoServiceProvider CreateRsaProviderFromPrivateKey(string privateKey)
	{
		var privateKeyBits = System.Convert.FromBase64String(privateKey);

		var RSA = new RSACryptoServiceProvider();
		var RSAparams = new RSAParameters();

		using (BinaryReader binr = new BinaryReader(new MemoryStream(privateKeyBits)))
		{
			byte bt = 0;
			ushort twobytes = 0;
			twobytes = binr.ReadUInt16();
			if (twobytes == 0x8130)
				binr.ReadByte();
			else if (twobytes == 0x8230)
				binr.ReadInt16();
			else
				throw new Exception("Unexpected value read binr.ReadUInt16()");

			twobytes = binr.ReadUInt16();
			if (twobytes != 0x0102)
				throw new Exception("Unexpected version");

			bt = binr.ReadByte();
			if (bt != 0x00)
				throw new Exception("Unexpected value read binr.ReadByte()");

			RSAparams.Modulus = binr.ReadBytes(GetIntegerSize(binr));
			RSAparams.Exponent = binr.ReadBytes(GetIntegerSize(binr));
			RSAparams.D = binr.ReadBytes(GetIntegerSize(binr));
			RSAparams.P = binr.ReadBytes(GetIntegerSize(binr));
			RSAparams.Q = binr.ReadBytes(GetIntegerSize(binr));
			RSAparams.DP = binr.ReadBytes(GetIntegerSize(binr));
			RSAparams.DQ = binr.ReadBytes(GetIntegerSize(binr));
			RSAparams.InverseQ = binr.ReadBytes(GetIntegerSize(binr));
		}

		RSA.ImportParameters(RSAparams);
		return RSA;
	}

	private int GetIntegerSize(BinaryReader binr)
	{
		byte bt = 0;
		byte lowbyte = 0x00;
		byte highbyte = 0x00;
		int count = 0;
		bt = binr.ReadByte();
		if (bt != 0x02)
			return 0;
		bt = binr.ReadByte();

		if (bt == 0x81)
			count = binr.ReadByte();
		else
			if (bt == 0x82)
		{
			highbyte = binr.ReadByte();
			lowbyte = binr.ReadByte();
			byte[] modint = { lowbyte, highbyte, 0x00, 0x00 };
			count = BitConverter.ToInt32(modint, 0);
		}
		else
		{
			count = bt;
		}

		while (binr.ReadByte() == 0x00)
		{
			count -= 1;
		}
		binr.BaseStream.Seek(-1, SeekOrigin.Current);
		return count;
	}

	private static string _privateKey;
	private static string _publicKey;
	private static UnicodeEncoding _encoder = new UnicodeEncoding();
	private static RSACryptoServiceProvider _rsaServiceProvider;
}
```
