# 搭配純前端框架做法

```cs
builder.Services.AddAntiforgery(options =>
                                {
                                    // options.HeaderName = "RequestVerificationToken"; // 預設的 Header
                                    // options.Cookie.Name                 = AntiforgeryConst.CookieName;

                                    // false 則不驗証 CSRF Token
                                    options.SuppressXFrameOptionsHeader = true;  

                                    options.Cookie.SameSite = SameSiteMode.Strict;

                                    // 預設只有 HttpOnly 而沒有 Secure Flag
                                    options.Cookie.SecurePolicy = CookieSecurePolicy.Always; 
                                });


// ...
app.UseStaticFiles();  

// 放在 UseStaticFiles() 之後，就不會對靜態檔案做驗証
app.UseMiddleware<CsrfTokenMiddleware>(); 

// ...
```


```cs
using Microsoft.AspNetCore.Antiforgery;

namespace WebApiVueDynamicTemplate.Infra;

/// <summary>
/// CSRF Token Middleware
/// <remarks>
/// 每次 response 都會回傳一個新的 CSRF Token 至 Cookie 中
/// 但是驗証 CSRF Token 的機制是透過 Http Header 中的 RequestVerificationToken 來驗証
/// 所以 CSRF Token 需要從 Cookie 中取出，放到 Http Header 中
/// 以簡化前端的程式碼
/// 除了 Http Get 外，其他 Http Method 都會透過預設的機制來檢查 CSRF Token
/// </remarks>
/// </summary>
public class CsrfTokenMiddleware
{
    private readonly RequestDelegate _next;
    private readonly IAntiforgery    _antiforgery;

    public CsrfTokenMiddleware(RequestDelegate next,
                               IAntiforgery    antiforgery)
    {
        _next        = next;
        _antiforgery = antiforgery;
    }

    public async Task Invoke(HttpContext context)
    {
        MoveCsrfTokenFromCookieToHeader(context);

        AssignCsrfToken(context);

        await _next.Invoke(context);
    }

    private void MoveCsrfTokenFromCookieToHeader(HttpContext context)
    {
        var csrfToken = context.Request.Cookies["RequestVerificationToken"];
        if (!string.IsNullOrEmpty(csrfToken))
        {
            context.Request.Headers.Add("RequestVerificationToken", csrfToken);
        }
    }

    private void AssignCsrfToken(HttpContext context)
    {
        var tokens = _antiforgery.GetAndStoreTokens(context);
        context.Response.Cookies.Append("RequestVerificationToken",
                                        tokens.RequestToken,
                                        new CookieOptions
                                        {
                                            HttpOnly = false,
                                        });
    }
}
```